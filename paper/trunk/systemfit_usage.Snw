%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using systemfit}\label{sec:Usage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Standard usage}

\pkg{systemfit} is generally called by
<<eval=FALSE>>=
systemfit( method, eqns )
@

There are two mandatory arguments: \code{method} and \code{eqns}.

The argument \code{method} is a string determining the estimation method.
It must be one of "OLS", "WLS", "SUR", "2SLS", "W2SLS" or "3SLS".

The other mandatory argument \code{eqns} is a list of the equations 
to estimate. 
Each equation is a standard formula in \proglang{R}.
It starts with a dependent variable on the left hand side.
After a tilde ($\sim$) the regressors are listed%
\footnote{For Details see the \proglang{R} help files to \code{formula}}.

This is now demonstrated using an example:
<<>>=
library( systemfit )
data( kmenta )
attach( kmenta )
fitsur <- systemfit( "SUR", list( q ~ p + d, q ~ p + f + a ) )
@

The first line loads the \pkg{systemfit} package.  The second line
loads example data that are included with the package.  These data
come from \cite{kmenta86}.  They are attached to the \proglang{R}
search path in line three.  In the last line, a seemingly unrelated
regression is performed.  The first equation represents the demand
side of the food market.  The dependant variable is \code{q} (food
consumption per capita).  The regressors are \code{p} (ratio of food
prices to general consumer prices)
and \code{d} (disposable income) as well as a constant%
\footnote{a regression constant is always implied if not explicitly omitted.}.
The second equation represents the supply side.
Variable \code{q} (food consumption per capita) is also the dependant 
variable of this equation. 
The regressors are again \code{p} (ratio of food prices to general 
consumer prices) and a constant as well as 
\code{f} (ratio of preceding year's prices received by farmers) and 
\code{a} (a time trend in years).
The regression result is assigned to the variable \code{fitsur}.

Summary results can be printed by\\
<<>>=
summary( fitsur )
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{User options}

Following additional options can be set by the user:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{Equation labels}
\paragraph{Equation labels}
The optional argument \code{eqnlabels} allows the user to label the equations.
It has to be a vector of strings naming the equations.\\
<<>>=
fitsur <- systemfit( "SUR", list( q ~ p + d, q ~ p + f + a ),
             eqnlabels = c( "demand", "supply" ) )
summary( fitsur )
@
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Instrumental variables}   
\paragraph{Instrumental variables}   
\code{inst}one-sided model formula specifying instrumental variables
   or a list of one-sided model formulas if different instruments should
   be used for the different equations (only needed for 2SLS, W2SLS and
   3SLS estimations).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Data}   
\paragraph{Data}   
\code{data} an optional data frame containing the variables in the model.
   By default the variables are taken from the environment from which
   systemfit is called.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Restrictions}   
\paragraph{Restrictions}   
\code{R.restr} an optional j x k matrix to impose linear
   restrictions on the parameters by \code{R.restr} * $\beta$ = \code{q.restr}
   (j = number of restrictions, k = number of all parameters,
   $\beta$ = vector of all parameters).

\code{q.restr} an optional j x 1 matrix to impose linear
   restrictions (see \code{R.restr}); default is a j x 1 matrix
   that contains only zeros.

\code{TX} an optional matrix to transform the regressor matrix and,
   hence, also the coefficient vector (see details).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Iteration control}   
\paragraph{Iteration control}
\code{maxiter} maximum number of iterations for WLS, SUR, W2SLS and
   3SLS estimations.

\code{tol} tolerance level indicating when to stop the iteration (only
   WLS, SUR, W2SLS and 3SLS estimations).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Residual covariance matrix}   
\paragraph{Residual covariance matrix}   
\code{rcovformula} formula to calculate the estimated residual covariance
   matrix (see details).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{3SLS formula}   
\paragraph{3SLS formula}   
\code{formula3sls} formula for calculating the 3SLS estimator,
   one of "GLS", "IV", "GMM", "Schmidt" or "EViews" (see details).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Degrees of freedom for t-tests}   
\paragraph{Degrees of freedom for t-tests}   
\code{probdfsys} use the degrees of freedom of the whole system
   (in place of the degrees of freedom of the single equation)
   to calculate prob values for the t-test of individual parameters.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{Sigma squared}   
\paragraph{Sigma squared}   
\code{single.eq.sigma} use different $\sigma^2$s for each
   single equation to calculate the covariance matrix and the
   standard errors of the coefficients (only OLS and 2SLS).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsection{System options}   
\paragraph{System options}   

\code{solvetol} tolerance level for detecting linear dependencies
   when inverting a matrix or calculating a determinant (see
   \code{solve} and \code{det}).

\code{saveMemory} save memory by omitting some calculation that
   are not crucial for the basic estimation (e.g McElroy's
   $R^2$).


